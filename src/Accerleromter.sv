
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================
`include types.svh


module Accerleromter(

	//////////// CLOCK //////////
	//input 		          		ADC_CLK_10,
	input 		          		MAX10_CLK1_50,
	//input 		          		MAX10_CLK2_50,

	//////////// SEG7 //////////
	output		     [7:0]		HEX0,
	output		     [7:0]		HEX1,
	output		     [7:0]		HEX2,
	output		     [7:0]		HEX3,
	output		     [7:0]		HEX4,
	output		     [7:0]		HEX5,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,
	
	//////////// GPIO //////////
	output		     [35:0]		debugGPIO,
	
	//////////// Accelerometer //////////
	output		          		GSENSOR_CS_N,
	input 		     [2:1]		GSENSOR_INT,
	output		          		GSENSOR_SCLK,
	inout 		          		GSENSOR_SDI,
	inout 		          		GSENSOR_SDO
);



//=======================================================
//  REG/WIRE declarations
//=======================================================

	wire rst;

	system_reset_controller #(
		.NO_OF_CLK_CYCLES( 40 )
	) rst_controller (
		.clk(MAX10_CLK1_50),
		.reset( rst )
	);

	
	assign LEDR = {2'b11, DBG_STATE};

//=======================================================
//  Structural coding
//=======================================================

	reg  [7:0] register_address;
	reg        R_W;
	reg  [7:0] write_data;
	wire [7:0] read_data;

	typedef enum {}
	wire [7:0] DBG_STATE;
	wire [7:0] DBG_VALS;
	reg  start_i2c_comms;
	wire i2c_comms_finished;
	wire ready;
	
//	assign debugGPIO[35:0] = {36{1'b0}};
	assign debugGPIO[1:0] = {GSENSOR_SCLK, GSENSOR_SDI};
	assign debugGPIO[4:2] = DBG_VALS[2:0];
//	assign debugGPIO[35:2] = {33{1'b1}};
	

	i2c_controller #(
		.SYS_CLK_SPEED (50000000),
		.I2C_CLK_SPEED (100000) //100000
	) G_SENSOR_i2c (
		.clk (MAX10_CLK1_50),
		.rst (rst),

		.GSENSOR_CS_N (GSENSOR_CS_N),
		.GSENSOR_INT  (GSENSOR_INT),
		.GSENSOR_SCL  (GSENSOR_SCLK),
		.GSENSOR_SDA  (GSENSOR_SDI),
		.ALT_ADDRESS  (GSENSOR_SDO),

		.DEV_ADDR (7'h1D), //Fixed for now as there is only one device
		.REG_ADDR (register_address),
		.R_W      (R_W),
		.WRITE_DATA (write_data),
		.READ_DATA  (read_data),
		
		.DBG_STATE(DBG_STATE),
		.DBG_VALS(DBG_VALS),

		.start_i2c_comms (start_i2c_comms),
		.i2c_comms_finished (i2c_comms_finished),
		.ready (ready)
	);

	reg data_read = 1'b0;
	reg refresh_pulse;
	always @(posedge MAX10_CLK1_50) begin
		if(rst) begin
			register_address <= 8'h0;
			R_W <= 1'b1;
			write_data <= 8'h0;
			start_i2c_comms <= 1'b0;
		end else begin
			if(ready & refresh_pulse) begin
				start_i2c_comms <= 1'b1;
				
			end else begin
				start_i2c_comms <= 1'b0;
			end
		end
	end

	`define REFRESH_RATE 50000000 // for 1 second
	reg [31:0] refresh_rate_counter;
	

	always @(posedge MAX10_CLK1_50) begin
		if(rst) begin
			refresh_rate_counter <= 0;
			refresh_pulse <= 1'b0;
		end
		if(refresh_rate_counter == `REFRESH_RATE) begin
			refresh_pulse <= 1'b1;
			refresh_rate_counter <= 0;
		end else begin
			refresh_pulse <= 1'b0;
			if(refresh_rate_counter = `REFRESH_RATE - 1) begin
				refresh_pulse <= 1'b1;
				refresh_rate_counter <= 0
			end else begin
				refresh_rate_counter = refresh_rate_counter + 1;
			end
		end
	end




endmodule
